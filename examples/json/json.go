// Code generated by pigeon (https://github.com/PuerkitoBio/pigeon)
// on 2015-05-04 12:45:56.651621305 -0400 EDT

// Command json parses JSON as defined by [1].
//
// BUGS: the escaped forward solidus (`\/`) is not currently handled.
//
// [1]: http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf
package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"unicode"
	"unicode/utf8"
)

func main() {
	in := os.Stdin
	nm := "stdin"
	if len(os.Args) > 1 {
		f, err := os.Open(os.Args[1])
		if err != nil {
			log.Fatal(err)
		}
		defer f.Close()
		in = f
		nm = os.Args[1]
	}

	got, err := ParseReader(nm, in)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(got)
}

func toIfaceSlice(v interface{}) []interface{} {
	if v == nil {
		return nil
	}
	return v.([]interface{})
}

func (c *current) onJSON1(vals interface{}) (interface{}, error) {
	valsSl := toIfaceSlice(vals)
	switch len(valsSl) {
	case 0:
		return nil, nil
	case 1:
		return valsSl[0], nil
	default:
		return valsSl, nil
	}
}

func (v *ϡvm) callOnJSON1() (interface{}, error) {
	stack := v.a.peek()
	return v.cur.onJSON1(stack["vals"])
}

func (c *current) onValue1(val interface{}) (interface{}, error) {
	return val, nil
}

func (v *ϡvm) callOnValue1() (interface{}, error) {
	stack := v.a.peek()
	return v.cur.onValue1(stack["val"])
}

func (c *current) onObject1(vals interface{}) (interface{}, error) {
	res := make(map[string]interface{})
	valsSl := toIfaceSlice(vals)
	if len(valsSl) == 0 {
		return res, nil
	}
	res[valsSl[0].(string)] = valsSl[4]
	restSl := toIfaceSlice(valsSl[5])
	for _, v := range restSl {
		vSl := toIfaceSlice(v)
		res[vSl[2].(string)] = vSl[6]
	}
	return res, nil
}

func (v *ϡvm) callOnObject1() (interface{}, error) {
	stack := v.a.peek()
	return v.cur.onObject1(stack["vals"])
}

func (c *current) onArray1(vals interface{}) (interface{}, error) {
	valsSl := toIfaceSlice(vals)
	if len(valsSl) == 0 {
		return []interface{}{}, nil
	}
	res := []interface{}{valsSl[0]}
	restSl := toIfaceSlice(valsSl[1])
	for _, v := range restSl {
		vSl := toIfaceSlice(v)
		res = append(res, vSl[2])
	}
	return res, nil
}

func (v *ϡvm) callOnArray1() (interface{}, error) {
	stack := v.a.peek()
	return v.cur.onArray1(stack["vals"])
}

func (c *current) onNumber1() (interface{}, error) {
	// JSON numbers have the same syntax as Go's, and are parseable using
	// strconv.
	return strconv.ParseFloat(string(c.text), 64)
}

func (v *ϡvm) callOnNumber1() (interface{}, error) {
	return v.cur.onNumber1()
}

func (c *current) onString1() (interface{}, error) {
	// TODO : the forward slash (solidus) is not a valid escape in Go, it will
	// fail if there's one in the string
	return strconv.Unquote(string(c.text))
}

func (v *ϡvm) callOnString1() (interface{}, error) {
	return v.cur.onString1()
}

func (c *current) onBool2() (interface{}, error) { return true, nil }

func (v *ϡvm) callOnBool2() (interface{}, error) {
	return v.cur.onBool2()
}

func (c *current) onBool4() (interface{}, error) { return false, nil }

func (v *ϡvm) callOnBool4() (interface{}, error) {
	return v.cur.onBool4()
}

func (c *current) onNull1() (interface{}, error) { return nil, nil }

func (v *ϡvm) callOnNull1() (interface{}, error) {
	return v.cur.onNull1()
}

var ϡtheProgram = &ϡprogram{
	instrs: []ϡinstr{
		3747557857108557824, 3747276386423799808, 288230376151711744,
		0, 3747557857155350528, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747557857113276416, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557852810641408,
		3747557857106132992, 3747276386423799808, 288230376151711744,
		3170815634120376320, 3459046083286532096, 1152921504606846976,
		1441433420159778816, 4611686018427387904, 3747557857106460672,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4900197878145744896, 4611686018427387904, 3747557857156202496,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3748120798469292055, 8162774324609024, 5188428430391115776,
		288230376151711744, 1152921504606846976, 1729663916570574848,
		1441433518944026624, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 3747557857107771392,
		288230376151711744, 1729663955225280512, 576742227280134144,
		4611686018427387904, 3170815616940507136, 4611686018427387904,
		3747557857122320384, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857128742912,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557857134444544, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747557857146437632, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857153581056,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557857154564096, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3748965223402700859, 18014694867075151, 5188428645139480576,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		2017894511765618688, 3170815625530441728, 1441433725102456832,
		3747557852810641408, 3170815621235474432, 4611686018427387904,
		3747557857111048192, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4900197891030646784, 4611686018427387904,
		3747557857155350528, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747276369243930624,
		3747557852810641408, 3747839323498610790, 5188428739628761088,
		288230376151711744, 1152921504606846976, 1729664225808220160,
		1441433828181671936, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 3747557857112555520,
		288230376151711744, 1729664264462925824, 576742231575101440,
		4611686018427387904, 3170815616940507136, 4611686018427387904,
		3747276369243930624, 2306124484190404608, 4323455642275676160,
		4611686018427387904, 3747557857155350528, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747557857146437632, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857155350528,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747276369243930624, 2306124488485371904,
		4323455642275676160, 4611686018427387904, 3747557857155350528,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557857113276416, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747276369243930624, 2306124492780339200, 4323455642275676160,
		4611686018427387904, 3747557857155350528, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747557857146437632, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857155350528,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747276369243930624, 2306124488485371904,
		4323455642275676160, 4611686018427387904, 3747557857155350528,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557857113276416, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747276369243930624, 3747557852810641408, 3749246698386292899,
		47288539128398006, 52635820644892672, 5188429113290915840,
		288230376151711744, 1152921504606846976, 1729664599470374912,
		1441434201843826688, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747557852810706944, 3747557857118126080,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		3459046903625285632, 1152921504606846976, 1441434240498532352,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3748965223408009356, 40814511583264973, 5188429203485229056,
		288230376151711744, 1152921504606846976, 1729664689664688128,
		1441434292038139904, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747557857119567872, 3747276386423799808,
		288230376151711744, 3170815634120376320, 3459046985229664256,
		4611686018427387904, 3747557852810575872, 4611686018427387904,
		3747557857120354304, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4900197878145744896, 4611686018427387904,
		3747276369243930624, 2306124497075306496, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3748402273453998210, 65866175342444544, 5188429332334247936,
		288230376151711744, 1152921504606846976, 1729664818513707008,
		1441434420887158784, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 3747557857121533952,
		288230376151711744, 1729664857168412672, 576742235870068736,
		4611686018427387904, 3170815616940507136, 4611686018427387904,
		3747276369243930624, 2306124501370273792, 4323455642275676160,
		4611686018427387904, 3747557857155350528, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747557857113276416, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747276369243930624,
		2306124492780339200, 4323455642275676160, 4611686018427387904,
		3747557857155350528, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857113276416,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3748120798487249178, 80783318315958272, 5188429538492678144,
		288230376151711744, 1152921504606846976, 1729665024672137216,
		1441434627045588992, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747557852810706944, 3747557857124679680,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		3459047328827047936, 1152921504606846976, 1441434665700294656,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3747839323510210864, 5188429624392024064, 288230376151711744,
		1152921504606846976, 1729665110571483136, 1441434712944934912,
		3170815621235474432, 4323455642275676160, 4611686018427387904,
		3747557857126055936, 3747276386423799808, 288230376151711744,
		3170815634120376320, 3459047406136459264, 4611686018427387904,
		3747557852810575872, 4611686018427387904, 3747557857126776832,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4900197878145744896, 4611686018427387904, 3747276369243930624,
		2306124505665241088, 4323455642275676160, 4611686018427387904,
		3747276369243930624, 3747557852810641408, 3748402273463042316,
		93451143966883840, 5188429753241042944, 288230376151711744,
		1152921504606846976, 1729665239420502016, 1441434841793953792,
		3170815621235474432, 4323455642275676160, 4611686018427387904,
		3747276369243930624, 3747557857127956480, 288230376151711744,
		1729665278075207680, 576742240165036032, 4611686018427387904,
		3170815616940507136, 4611686018427387904, 3747276369243930624,
		2306124509960208384, 4323455642275676160, 4611686018427387904,
		3747557857129267200, 3747276386423799808, 288230376151711744,
		3170815634120376320, 3459047586525085696, 4611686018427387904,
		3747557852810575872, 4611686018427387904, 3747557857137197056,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747276369243930624, 2306124514255175680,
		4323455642275676160, 4611686018427387904, 3747557857151221760,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557852810641408, 3747557857130643456,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		3459047689604300800, 1152921504606846976, 1441435026477547520,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3747839323517157764, 5188429985169276928, 288230376151711744,
		1152921504606846976, 1729665471348736000, 1441435073722187776,
		3170815621235474432, 4323455642275676160, 4611686018427387904,
		3747557857131560960, 3747276386423799808, 288230376151711744,
		3170815634120376320, 3459047766913712128, 4611686018427387904,
		3747557852810575872, 4611686018427387904, 3747557857139884032,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557857132806144, 3747276386423799808,
		288230376151711744, 3170815634120376320, 3459047822748286976,
		4611686018427387904, 3747557852810575872, 4611686018427387904,
		3747276369243930624, 3747557852810641408, 3748402273469727094,
		114843598679179264, 5188430126903197696, 288230376151711744,
		1152921504606846976, 1729665613082656768, 1441435215456108544,
		3170815621235474432, 4323455642275676160, 4611686018427387904,
		3747276369243930624, 3747557857133658112, 288230376151711744,
		1729665651737362432, 576742244460003328, 4611686018427387904,
		3170815616940507136, 4611686018427387904, 3747276369243930624,
		2306124518550142976, 4323455642275676160, 4611686018427387904,
		3747557857151483904, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857151221760,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557852810706944, 3747557857135558656,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		3459048011726848000, 1152921504606846976, 1441435348600094720,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3747839323522007503, 5188430307291824128, 288230376151711744,
		1152921504606846976, 1729665793471283200, 1441435395844734976,
		3170815621235474432, 4323455642275676160, 4611686018427387904,
		3747839323521745368, 5188430354536464384, 3747276386423799808,
		288230376151711744, 3170815634120376320, 2017896221162602496,
		3170815625530441728, 1441435434499440640, 3747557852810641408,
		3170815621235474432, 4611686018427387904, 3747276369243930624,
		2306124522845110272, 4323455642275676160, 4611686018427387904,
		3747276369243930624, 2306124527140077568, 4323455642275676160,
		4611686018427387904, 3747557857138180096, 3747276386423799808,
		288230376151711744, 3170815634120376320, 3459048170640637952,
		4611686018427387904, 3747557852810575872, 4611686018427387904,
		3747557857151221760, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557852810641408,
		3747557857138966528, 3747276386423799808, 288230376151711744,
		3170815634120376320, 3459048235065147392, 1152921504606846976,
		1441435571938394112, 4611686018427387904, 3747276369243930624,
		3747557852810641408, 3748120798501405174, 144959613005987840,
		5188430534925090816, 288230376151711744, 1152921504606846976,
		1729666021104549888, 1441435623478001664, 3170815621235474432,
		4323455642275676160, 4611686018427387904, 3747276369243930624,
		2306124531435044864, 4323455642275676160, 4611686018427387904,
		3747557857146961920, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747276369243930624,
		3747557857140932608, 3747276386423799808, 288230376151711744,
		3170815634120376320, 2594073385365405696, 4035225266123964416,
		4611686018427387904, 3747276369243930624, 2306124535730012160,
		4323455642275676160, 4611686018427387904, 3747276369243930624,
		3747557852810641408, 3747839323528036905, 5188430672364044288,
		288230376151711744, 1152921504606846976, 1729666158543503360,
		1441435760916955136, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 2306124540024979456,
		4323455642275676160, 4611686018427387904, 3747557857147879424,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3747839323529544252, 5188430758263390208, 288230376151711744,
		1152921504606846976, 1729666244442849280, 1441435846816301056,
		3170815621235474432, 4323455642275676160, 4611686018427387904,
		3747839323528823361, 5188430805508030464, 3747276386423799808,
		288230376151711744, 3170815634120376320, 2017896672134168576,
		3170815625530441728, 1441435885471006720, 3747557852810641408,
		3170815621235474432, 4611686018427387904, 3747557852810706944,
		3747557857144078336, 3747276386423799808, 288230376151711744,
		3170815634120376320, 3459048595842400256, 1152921504606846976,
		1441435932715646976, 4611686018427387904, 3747276369243930624,
		2306124531435044864, 4323455642275676160, 4611686018427387904,
		3747276369243930624, 3747557852810641408, 3748120798504157783,
		171136785840078848, 5188430912882212864, 288230376151711744,
		1152921504606846976, 1729666399061671936, 1441436001435123712,
		3170815621235474432, 4323455642275676160, 4611686018427387904,
		3747276369243930624, 3747557857145651200, 288230376151711744,
		1729666437716377600, 576742248754970624, 4611686018427387904,
		3170815616940507136, 4611686018427387904, 3747276369243930624,
		2306124544319946752, 4323455642275676160, 4611686018427387904,
		3747557857148600320, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857150435328,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747839323534000769, 5188431054616133632,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		2017896921242271744, 3170815625530441728, 1441436134579109888,
		3747557852810641408, 3170815621235474432, 4611686018427387904,
		3747276369243930624, 2306124548614914048, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 2306124552909881344,
		4323455642275676160, 4611686018427387904, 3747557857151746048,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747557857151746048, 3747276386423799808,
		288230376151711744, 3170815634120376320, 4611686018427387904,
		3747557857151746048, 3747276386423799808, 288230376151711744,
		3170815634120376320, 4611686018427387904, 3747557857151746048,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		4611686018427387904, 3747276369243930624, 3747557852810641408,
		3748683748465771161, 188591133543628800, 5188431226414825472,
		288230376151711744, 1152921504606846976, 1729666712594284544,
		1441436314967736320, 3170815621235474432, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 2306124557204848640,
		4323455642275676160, 4611686018427387904, 3747276369243930624,
		2306124561499815936, 4323455642275676160, 4611686018427387904,
		3747276369243930624, 2306124565794783232, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 2306124570089750528,
		4323455642275676160, 4611686018427387904, 3747276369243930624,
		3747557857152008192, 288230376151711744, 1729666819968466944,
		576742253049937920, 4611686018427387904, 3170815616940507136,
		4611686018427387904, 3747276369243930624, 2306124574384717824,
		4323455642275676160, 4611686018427387904, 3747276369243930624,
		3747557857152794624, 288230376151711744, 1729666871508074496,
		576742257344905216, 4611686018427387904, 3170815616940507136,
		4611686018427387904, 3747839323539047125, 5188431428278288384,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		2017897294904426496, 3170815625530441728, 1441436508241264640,
		3747557852810641408, 3170815621235474432, 4611686018427387904,
		3747276369243930624, 2306124578679685120, 4323455642275676160,
		4611686018427387904, 3747276369243930624, 3747557857154301952,
		288230376151711744, 1729666970292322304, 576742261639872512,
		4611686018427387904, 3170815616940507136, 4611686018427387904,
		3747276369243930624, 2306124582974652416, 4323455642275676160,
		4611686018427387904, 3747557852810706944, 3747557857155088384,
		3747276386423799808, 288230376151711744, 3170815634120376320,
		3459049287332134912, 1152921504606846976, 1441436624205381632,
		4611686018427387904, 3747276369243930624, 2306124535730012160,
		4323455642275676160, 4611686018427387904, 3747276369243930624,
		3747557857155940352, 3747276386423799808, 288230376151711744,
		3170815634120376320, 2594073385365405696, 4035225266123964416,
		4611686018427387904,
	},
	instrToRule: []int{
		-1, -1, -1, -1, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		3, 3, 3, 3, 3, 3, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		8, 8, 8, 8, 8, 8, 8, 8, 8, 12,
		12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
		12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
		12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
		12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
		12, 12, 12, 12, 14, 14, 14, 14, 14, 14,
		14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
		14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
		14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
		14, 14, 14, 14, 14, 14, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		9, 9, 16, 16, 16, 16, 17, 17, 17, 17,
		17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
		17, 17, 17, 17, 17, 17, 17, 18, 18, 18,
		18, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
		19, 19, 19, 19, 19, 19, 19, 13, 13, 13,
		13, 15, 15, 15, 15, 20, 20, 20, 20, 10,
		10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
		10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
		10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
		10, 10, 10, 10, 11, 11, 11, 11, 11, 11,
		11, 11, 11, 11, 11, 11, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 4,
		4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4,
	},
	ss: []string{
		"JSON", "_", "vals",
		"Value", "EOF", "val",
		"Object", "Array", "Number",
		"String", "Bool", "Null",
		"Integer", "DecimalDigit", "Exponent",
		"NonZeroDecimalDigit", "EscapedChar", "EscapeSequence",
		"SingleCharEscape", "UnicodeEscape", "HexDigit",
		"\"whitespace\"",
	},
	ms: []ϡmatcher{
		ϡstringMatcher{
			ignoreCase: false,
			value:      "{",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      ":",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      ",",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "}",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "[",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "]",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "-",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      ".",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "0",
		},
		ϡstringMatcher{
			ignoreCase: true,
			value:      "e",
		},
		ϡcharClassMatcher{
			ignoreCase: false,
			inverted:   false,
			chars:      []rune{'+', '-'},
			ranges:     []rune{},
			classes:    []*unicode.RangeTable{},
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "\"",
		},
		ϡanyMatcher{},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "\\",
		},
		ϡcharClassMatcher{
			ignoreCase: false,
			inverted:   false,
			chars:      []rune{'"', '\\'},
			ranges:     []rune{'\x00', '\x1f'},
			classes:    []*unicode.RangeTable{},
		},
		ϡcharClassMatcher{
			ignoreCase: false,
			inverted:   false,
			chars:      []rune{'"', '\\', '/', 'b', 'f', 'n', 'r', 't'},
			ranges:     []rune{},
			classes:    []*unicode.RangeTable{},
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "u",
		},
		ϡcharClassMatcher{
			ignoreCase: false,
			inverted:   false,
			chars:      []rune{},
			ranges:     []rune{'0', '9'},
			classes:    []*unicode.RangeTable{},
		},
		ϡcharClassMatcher{
			ignoreCase: false,
			inverted:   false,
			chars:      []rune{},
			ranges:     []rune{'1', '9'},
			classes:    []*unicode.RangeTable{},
		},
		ϡcharClassMatcher{
			ignoreCase: true,
			inverted:   false,
			chars:      []rune{},
			ranges:     []rune{'0', '9', 'a', 'f'},
			classes:    []*unicode.RangeTable{},
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "true",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "false",
		},
		ϡstringMatcher{
			ignoreCase: false,
			value:      "null",
		},
		ϡcharClassMatcher{
			ignoreCase: false,
			inverted:   false,
			chars:      []rune{' ', '\t', '\r', '\n'},
			ranges:     []rune{},
			classes:    []*unicode.RangeTable{},
		},
	},
	as: []func(*ϡvm) (interface{}, error){
		(*ϡvm).callOnJSON1,
		(*ϡvm).callOnValue1,
		(*ϡvm).callOnObject1,
		(*ϡvm).callOnArray1,
		(*ϡvm).callOnNumber1,
		(*ϡvm).callOnString1,
		(*ϡvm).callOnBool2,
		(*ϡvm).callOnBool4,
		(*ϡvm).callOnNull1,
	},
	bs: []func(*ϡvm) (bool, error){},
}

//+pigeon: err.go

var (
	// errInvalidEncoding is returned when the source is not properly
	// utf8-encoded.
	errInvalidEncoding = errors.New("invalid encoding")

	// errNoMatch is returned if no match could be found and no other
	// error has been raised.
	errNoMatch = errors.New("no match found")
)

// errList cumulates the errors found by the parser. It is part
// of the supported API.
type errList []error

// ϡadd adds err to the list of errors.
func (e *errList) ϡadd(err error) {
	if err != nil {
		*e = append(*e, err)
	}
}

// ϡerr returns the error list as an error, or nil if the list is empty.
func (e errList) ϡerr() error {
	if len(e) == 0 {
		return nil
	}
	e.ϡdedupe()
	return e
}

// ϡdedupe removes duplicate error messages from the list.
func (e *errList) ϡdedupe() {
	var cleaned []error
	set := make(map[string]bool)
	for _, err := range *e {
		if msg := err.Error(); !set[msg] {
			set[msg] = true
			cleaned = append(cleaned, err)
		}
	}
	*e = cleaned
}

// Error returns the error message for the errList. It implements the
// error interface.
func (e errList) Error() string {
	var buf bytes.Buffer

	for i, err := range e {
		if i > 0 {
			buf.WriteRune('\n')
		}
		buf.WriteString(err.Error())
	}
	return buf.String()
}

// parserError wraps an error with a prefix indicating the rule in which
// the error occurred. The original error is stored in the Inner field.
// It is part of the supported API.
type parserError struct {
	Inner   error
	ϡpos    position
	ϡprefix string
}

// Error returns the prefixed error message. It implements the error
// interface.
func (p *parserError) Error() string {
	return p.ϡprefix + ": " + p.Inner.Error()
}

//+pigeon: matchers.go

// ϡpeekReader is the interface that defines the peek and read
// methods.
type ϡpeekReader interface {
	peek() ϡsvpt
	read()
}

// ϡmatcher is the interface that defines the match method.
type ϡmatcher interface {
	match(ϡpeekReader) bool
}

// ϡanyMatcher is a matcher that matches any character but the
// EOF.
type ϡanyMatcher struct{}

// match tries to match a character in the peekReader.
func (a ϡanyMatcher) match(pr ϡpeekReader) bool {
	pt := pr.peek()
	pr.read()
	return pt.rn != utf8.RuneError
}

func (a ϡanyMatcher) String() string {
	return "."
}

// ϡstringMatcher is a matcher that matches a string.
type ϡstringMatcher struct {
	ignoreCase bool
	value      string // value must be lowercase if ignoreCase is true
}

// match tries to match the string in the peekReader.
func (s ϡstringMatcher) match(pr ϡpeekReader) bool {
	for _, want := range s.value {
		pt := pr.peek()
		if s.ignoreCase {
			pt.rn = unicode.ToLower(pt.rn)
		}
		if pt.rn != want {
			return false
		}
		pr.read()
	}
	return true
}

func (s ϡstringMatcher) String() string {
	v := strconv.Quote(s.value)
	if s.ignoreCase {
		v += "i"
	}
	return v
}

// ϡcharClassMatcher is a matcher that matches classes of characters.
type ϡcharClassMatcher struct {
	chars   []rune // runes must be lowercase if ignoreCase is true
	ranges  []rune // same for ranges
	classes []*unicode.RangeTable

	ignoreCase bool
	inverted   bool
}

func (c ϡcharClassMatcher) String() string {
	var buf bytes.Buffer

	buf.WriteString("[")
	if c.inverted {
		buf.WriteString("^")
	}
	for _, c := range c.chars {
		buf.WriteRune(c)
	}
	for i := 0; i < len(c.ranges); i += 2 {
		buf.WriteString(fmt.Sprintf("%c-%c", c.ranges[i], c.ranges[i+1]))
	}
	// unicode classes can't be stringified
	if l := len(c.classes); l > 0 {
		buf.WriteString(fmt.Sprintf("\\p{%d classes}", l))
	}
	buf.WriteString("]")
	if c.ignoreCase {
		buf.WriteString("i")
	}
	return buf.String()
}

// match tries to match classes of characters in the peekReader.
func (c ϡcharClassMatcher) match(pr ϡpeekReader) bool {
	pt := pr.peek()
	pr.read()

	if c.ignoreCase {
		pt.rn = unicode.ToLower(pt.rn)
	}

	// try to match in the list of available chars
	for _, rn := range c.chars {
		if pt.rn == rn {
			return !c.inverted
		}
	}

	// try to match in the list of ranges
	for i := 0; i < len(c.ranges); i += 2 {
		if pt.rn >= c.ranges[i] && pt.rn <= c.ranges[i+1] {
			return !c.inverted
		}
	}

	// try to match in the list of Unicode classes
	for _, cl := range c.classes {
		if unicode.Is(cl, pt.rn) {
			return !c.inverted
		}
	}

	return c.inverted
}

// ϡrangeTable returns the corresponding unicode range table from the
// provided class name.
func ϡrangeTable(class string) *unicode.RangeTable {
	if rt, ok := unicode.Categories[class]; ok {
		return rt
	}
	if rt, ok := unicode.Properties[class]; ok {
		return rt
	}
	if rt, ok := unicode.Scripts[class]; ok {
		return rt
	}

	// cannot happen
	panic(fmt.Sprintf("invalid Unicode class: %s", class))
}

//+pigeon: ops.go

// ϡop represents an opcode.
type ϡop byte

// list of opcodes in the pigeon VM.
const (
	ϡopExit ϡop = iota
	ϡopCall
	ϡopCallA
	ϡopCallB
	ϡopCumulOrF
	ϡopJump
	ϡopJumpIfF
	ϡopJumpIfT
	ϡopMatch
	ϡopNilIfF
	ϡopNilIfT
	ϡopPop
	ϡopPopVJumpIfF
	ϡopPush
	ϡopRestore
	ϡopRestoreIfF
	ϡopReturn
	ϡopStoreIfT
	ϡopTakeLOrJump
	ϡopmax // must always be after the last valid opcode

	// ϡopPlaceholder is an (invalid) opcode used by the Generator
	// to insert opcodes that need the index of the starting instruction
	// of a rule that hasn't been generated yet.
	//
	// It must be placed after ϡopmax (because it is invalid in the
	// final program) and it has one argument, the index in the strings
	// array of the identifier of the rule.
	ϡopPlaceholder
)

// ϡlookupOp translates an opcode to a string.
var ϡlookupOp = []string{
	ϡopExit: "exit", ϡopCall: "call", ϡopCallA: "callA",
	ϡopCallB: "callB", ϡopCumulOrF: "cumulOrF",
	ϡopJump: "jump", ϡopJumpIfF: "jumpIfF", ϡopJumpIfT: "jumpIfT",
	ϡopMatch: "match", ϡopNilIfF: "nilIfF", ϡopNilIfT: "nilIfT",
	ϡopPop: "pop", ϡopPopVJumpIfF: "popVJumpIfF",
	ϡopPush: "push", ϡopRestore: "restore", ϡopRestoreIfF: "restoreIfF",
	ϡopReturn: "return", ϡopStoreIfT: "storeIfT", ϡopTakeLOrJump: "takeLOrJump",
}

// String returns the string representation of the opcode.
func (op ϡop) String() string {
	if 0 <= op && int(op) < len(ϡlookupOp) {
		return ϡlookupOp[op]
	}
	return "ϡop(" + strconv.Itoa(int(op)) + ")"
}

// ϡinstr encodes an opcode with its arguments as a 64-bits unsigned
// integer. The bits are used as follows:
//
// o : 6 bits = opcode (max=63)
// n : 10 bits = for PUSHL, number of values in array (max=1023)
// l : 16 bits = instruction index (max=65535)
//
// So a single PUSH instruction can encode 2 indices (first arg is the stack ID).
// The 64-bit value looks like this:
// oooooonn nnnnnnnn llllllll llllllll llllllll llllllll llllllll llllllll
//
// And if a PUSH (L) instruction has more than 2 indices, it can store 4 full
// indices per subsequent values (4 * 16 bits = 64 bits).
type ϡinstr uint64

// limits and masks.
const (
	ϡiBits = 64
	ϡlBits = 16
	ϡnBits = 10
	ϡoBits = 6
	ϡlPerI = ϡiBits / ϡlBits

	ϡlMask = 1<<ϡlBits - 1
	ϡnMask = 1<<ϡnBits - 1
	ϡoMask = 1<<ϡoBits - 1
)

// decode decodes the instruction and returns the 5 parts:
// the opcode, the number of L array values, and the 3 instruction
// indices.
func (i ϡinstr) decode() (op ϡop, n, ix0, ix1, ix2 int) {
	ix2 = int(i & ϡlMask)
	i >>= ϡlBits
	ix1 = int(i & ϡlMask)
	i >>= ϡlBits
	ix0 = int(i & ϡlMask)
	i >>= ϡlBits
	n = int(i & ϡnMask)
	i >>= ϡnBits
	op = ϡop(i & ϡoMask)
	return
}

// decodeLs decodes the instruction as a list of L instruction
// indices (as a follow-up value to a PUSHL opcode).
func (i ϡinstr) decodeLs() (ix0, ix1, ix2, ix3 int) {
	ix3 = int(i & ϡlMask)
	i >>= ϡlBits
	ix2 = int(i & ϡlMask)
	i >>= ϡlBits
	ix1 = int(i & ϡlMask)
	i >>= ϡlBits
	ix0 = int(i & ϡlMask)
	return
}

// ϡencodeInstr encodes the provided operation and its arguments into
// a list of instruction values. It may return an error if any part
// of the instruction overflows the allowed values.
func ϡencodeInstr(op ϡop, args ...int) ([]ϡinstr, error) {
	var is []ϡinstr

	if op >= ϡopmax && op != ϡopPlaceholder {
		return nil, errors.New("invalid op value")
	}
	if len(args) > ϡnMask {
		return nil, errors.New("too many arguments")
	}

	// first instruction contains opcode
	is = append(is, ϡinstr(op)<<(ϡiBits-ϡoBits))
	n := uint(len(args))
	if n == 0 {
		return is, nil
	}
	off := uint(ϡiBits - ϡoBits - ϡnBits)
	is[0] |= ϡinstr(n) << off

	ix := 0
	for i, arg := range args {
		if arg > ϡlMask {
			return nil, errors.New("argument value too big")
		}

		mod := uint((i + 1) % ϡlPerI)
		if mod == 0 {
			is = append(is, 0)
			ix++
		}

		is[ix] |= ϡinstr(arg) << (off - (mod * ϡlBits))
	}

	return is, nil
}

//+pigeon: parser.go

// position records a position in the text. It is part of the supported
// API.
type position struct {
	// line is the 1-based index of the line of the current rune.
	line int
	// col is the 1-based index of the current rune on the line.
	col int
	// offset is the 0-based index of the starting byte of the current rune.
	offset int
}

// String formats a position as a string.
func (p position) String() string {
	return fmt.Sprintf("%d:%d (%d)", p.line, p.col, p.offset)
}

// current represents current matching data. It is the value on which
// action and predicate code blocks are generated as methods. It is
// part of the supported API.
type current struct {
	// pos holds the start position of the current match.
	pos position
	// text contains the raw text of the match. It is a slice in the
	// source data, so it should not be modified.
	text []byte
}

// ϡsvpt stores all state required to go back to a point in the
// parser.
type ϡsvpt struct {
	position
	rn rune
	w  int
}

// ϡparser parses the input text as rune code points.
type ϡparser struct {
	data []byte
	pt   ϡsvpt
	cur  current
}

// peek returns the current savepoint information.
func (p *ϡparser) peek() ϡsvpt {
	return p.pt
}

// read advances the parser to the next rune.
func (p *ϡparser) read() {
	p.pt.offset += p.pt.w
	rn, n := utf8.DecodeRune(p.data[p.pt.offset:])
	p.pt.rn = rn
	p.pt.w = n

	if rn == utf8.RuneError {
		if n > 0 {
			panic(errInvalidEncoding)
		}
	} else {
		p.pt.col++
		if rn == '\n' {
			p.pt.line++
			p.pt.col = 0
		}
	}
}

// sliceFrom gets the slice of bytes from the start savepoint to
// the current position, non inclusive.
func (p *ϡparser) sliceFrom(start ϡsvpt) []byte {
	return p.data[start.position.offset:p.pt.position.offset]
}

//+pigeon: pub.go

// Option is a function that can set an option on the parser. It returns
// the previous setting as an Option.
type Option func(*ϡvm) Option

// Debug creates an Option to set the debug flag to b. When set to true,
// debugging information is printed to stdout while parsing.
//
// The default is false.
func Debug(b bool) Option {
	return func(v *ϡvm) Option {
		old := v.debug
		v.debug = b
		return Debug(old)
	}
}

// Memoize creates an Option to set the memoize flag to b. When set to true,
// the parser will cache all results so each expression is evaluated only
// once. This guarantees linear parsing time even for pathological cases,
// at the expense of more memory and slower times for typical cases.
//
// The default is false.
func Memoize(b bool) Option {
	return func(v *ϡvm) Option {
		old := v.memoize
		v.memoize = b
		return Memoize(old)
	}
}

// Recover creates an Option to set the recover flag to b. When set to
// true, this causes the parser to recover from panics and convert it
// to an error. Setting it to false can be useful while debugging to
// access the full stack trace.
//
// The default is true.
func Recover(b bool) Option {
	return func(v *ϡvm) Option {
		old := v.recover
		v.recover = b
		return Recover(old)
	}
}

// ParseFile parses the file identified by filename.
func ParseFile(filename string, opts ...Option) (interface{}, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return ParseReader(filename, f, opts...)
}

// ParseReader parses the data from r using filename as information in the
// error messages.
func ParseReader(filename string, r io.Reader, opts ...Option) (interface{}, error) {
	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}

	return Parse(filename, b, opts...)
}

// Parse parses the data from b using filename as information in the
// error messages.
func Parse(filename string, b []byte, opts ...Option) (interface{}, error) {
	p := &ϡparser{
		data: b,
		pt:   ϡsvpt{position: position{line: 1}},
	}
	v := &ϡvm{
		filename: filename,
		parser:   p,
		recover:  true,
	}
	return v.setOptions(opts).run(ϡtheProgram)
}

//+pigeon: stacks.go

// ϡpstack implements the Position stack. It stores savepoints.
type ϡpstack []ϡsvpt

// push adds a value on the stack.
func (p *ϡpstack) push(pt ϡsvpt) {
	*p = append(*p, pt)
}

// pop removes a value from the stack.
func (p *ϡpstack) pop() ϡsvpt {
	n := len(*p)
	// if n == 0 {
	// 	panic("pstack is empty")
	// }
	v := (*p)[n-1]
	*p = (*p)[:n-1]
	return v
}

// ϡistack implements the Instruction index stack. It stores integers.
type ϡistack []int

// push adds a value on the stack.
func (i *ϡistack) push(v int) {
	*i = append(*i, v)
}

// pop removes a value from the stack.
func (i *ϡistack) pop() int {
	n := len(*i)
	// if n == 0 {
	// 	panic("istack is empty")
	// }
	v := (*i)[n-1]
	*i = (*i)[:n-1]
	return v
}

// ϡvstack implements the Value stack. It stores empty interfaces.
type ϡvstack []interface{}

// push adds a value on the stack.
func (v *ϡvstack) push(i interface{}) {
	*v = append(*v, i)
}

// pop removes a value from the stack.
func (v *ϡvstack) pop() interface{} {
	i := v.peek()
	*v = (*v)[:len(*v)-1]
	return i
}

// peek returns the value at the top of the stack, leaving it there.
func (v *ϡvstack) peek() interface{} {
	n := len(*v)
	// if n == 0 {
	// 	panic("vstack is empty")
	// }
	i := (*v)[n-1]
	return i
}

// ϡlstack implements the Loop stack. It stores slices of integers.
type ϡlstack [][]int

// push adds a value on the stack.
func (l *ϡlstack) push(a []int) {
	*l = append(*l, a)
}

// pop removes a value from the stack.
func (l *ϡlstack) pop() []int {
	n := len(*l)
	// if n == 0 {
	// 	panic("lstack is empty")
	// }
	a := (*l)[n-1]
	*l = (*l)[:n-1]
	return a
}

// take removes the integer at index 0 from the slice at the top of the
// stack. It returns -1 if the slice is empty. The slice is left on the
// stack.
func (l *ϡlstack) take() int {
	n := len(*l)
	// if n == 0 {
	// 	panic("lstack is empty")
	// }

	v := -1
	a := (*l)[n-1]
	if len(a) > 0 {
		v = a[0]
		(*l)[n-1] = a[1:]
	}
	return v
}

// ϡargsSet holds the list of arguments (key and value) to pass
// to the code blocks.
type ϡargsSet map[string]interface{}

// ϡastack is a stack of ϡargsSet.
type ϡastack []ϡargsSet

// push adds an empty ϡargsSet on top of the stack.
func (a *ϡastack) push() {
	*a = append(*a, ϡargsSet{})
}

// pop removes the top ϡargsSet from the stack.
func (a *ϡastack) pop() {
	n := len(*a)
	// if n == 0 {
	// 	panic("astack is empty")
	// }
	*a = (*a)[:n-1]
}

// peek returns the current top ϡargsSet.
func (a *ϡastack) peek() ϡargsSet {
	n := len(*a)
	// if n == 0 {
	// 	panic("astack is empty")
	// }
	as := (*a)[n-1]
	return as
}

//+pigeon: vm.go

// ϡsentinel is a type used to define sentinel values that shouldn't
// be equal to something else.
type ϡsentinel int

const (
	// ϡmatchFailed is a sentinel value used to indicate a match failure.
	ϡmatchFailed ϡsentinel = iota - 1
)

const (
	// stack IDs, used in PUSH and POP's first argument
	ϡpstackID = iota + 1
	ϡlstackID
	ϡvstackID
	ϡistackID
	ϡastackID

	// special V stack values
	ϡvValNil    = 0
	ϡvValFailed = 1
	ϡvValEmpty  = 2
)

var (
	ϡstackNm = []string{
		ϡpstackID: "P",
		ϡlstackID: "L",
		ϡvstackID: "V",
		ϡistackID: "I",
		ϡastackID: "A",
	}
)

// special values that may be pushed on the V stack.
var ϡvSpecialValues = []interface{}{
	nil,
	ϡmatchFailed,
	[]interface{}(nil),
}

type ϡmemoizedResult struct {
	v  interface{}
	pt ϡsvpt
}

// ϡprogram is the data structure that is generated by the builder
// based on an input PEG. It contains the program information required
// to execute the grammar using the vm.
type ϡprogram struct {
	instrs []ϡinstr

	// lists
	ms []ϡmatcher
	as []func(*ϡvm) (interface{}, error)
	bs []func(*ϡvm) (bool, error)
	ss []string

	// instrToRule is the mapping of an instruction index to a rule
	// identifier (or display name) in the ss list:
	//
	// ss[instrToRule[instrIndex]] == name of the rule
	//
	// Since instructions are limited to 65535, the size of this slice
	// is bounded.
	instrToRule []int
}

// String formats the program's instructions in a human-readable format.
func (pg ϡprogram) String() string {
	var buf bytes.Buffer
	var n int

	for i, instr := range pg.instrs {
		if n > 0 {
			n -= 4
			continue
		}
		_, n, _, _, _ = instr.decode()
		n -= 3

		buf.WriteString(fmt.Sprintf("[%3d]: %s\n", i, pg.instrToString(instr, i)))
	}
	return buf.String()
}

// instrToString formats an instruction in a human-readable format, in the
// context of the program.
func (pg ϡprogram) instrToString(instr ϡinstr, ix int) string {
	var buf bytes.Buffer

	op, n, a0, a1, a2 := instr.decode()
	rule := pg.ruleNameAt(ix)
	if rule == "" {
		rule = "<bootstrap>"
	}
	stdFmt := "%s.%s"
	switch op {
	case ϡopCall, ϡopCumulOrF, ϡopReturn, ϡopExit, ϡopRestore,
		ϡopRestoreIfF, ϡopNilIfF, ϡopNilIfT:
		buf.WriteString(fmt.Sprintf(stdFmt, rule, op))
	case ϡopCallA, ϡopCallB, ϡopJump, ϡopJumpIfT, ϡopJumpIfF, ϡopPopVJumpIfF, ϡopTakeLOrJump:
		buf.WriteString(fmt.Sprintf(stdFmt+" %d", rule, op, a0))
	case ϡopPush:
		buf.WriteString(fmt.Sprintf(stdFmt+" %s %d %d", rule, op, ϡstackNm[a0], a1, a2))
		orin := n
		n -= 3
		for n > 0 {
			ix++
			a0, a1, a2, a3 := pg.instrs[ix].decodeLs()
			n -= 4
			buf.WriteString(fmt.Sprintf(" %d %d %d %d", a0, a1, a2, a3))
		}
		buf.WriteString(fmt.Sprintf(" (n=%d)", orin))
	case ϡopPop:
		buf.WriteString(fmt.Sprintf(stdFmt+" %s", rule, op, ϡstackNm[a0]))
	case ϡopMatch:
		buf.WriteString(fmt.Sprintf(stdFmt+" %d (%s)", rule, op, a0, pg.ms[a0]))
	case ϡopStoreIfT:
		buf.WriteString(fmt.Sprintf(stdFmt+" %d (%s)", rule, op, a0, pg.ss[a0]))
	default:
		buf.WriteString(fmt.Sprintf(stdFmt+" %d %d", rule, op, a0, a1))
	}
	return buf.String()
}

// ruleNameAt returns the name of the rule that contains the instruction
// index. It returns an empty string is the instruction is not part of a
// rule (bootstrap instruction, invalid index).
func (pg ϡprogram) ruleNameAt(instrIx int) string {
	if instrIx < 0 || instrIx >= len(pg.instrToRule) {
		return ""
	}
	ssIx := pg.instrToRule[instrIx]
	if ssIx < 0 || ssIx >= len(pg.ss) {
		return ""
	}
	return pg.ss[ssIx]
}

// ϡvm holds the state to execute a compiled grammar.
type ϡvm struct {
	// input
	filename string
	parser   *ϡparser

	// options
	debug   bool
	memoize bool
	recover bool
	// TODO : no bounds checking option (for stacks)? benchmark to see if it's worth it.

	// program data
	pc  int
	pg  *ϡprogram
	cur current

	// stacks
	p ϡpstack
	l ϡlstack
	v ϡvstack
	i ϡistack
	a ϡastack

	// TODO: memoization...
	// TODO: farthest failure position

	// error list
	errs errList
}

// setOptions applies the options in sequence on the vm. It returns the
// vm to allow for chaining calls.
func (v *ϡvm) setOptions(opts []Option) *ϡvm {
	for _, opt := range opts {
		opt(v)
	}
	return v
}

// addErr adds the error at the current parser position, without rule name
// information.
func (v *ϡvm) addErr(err error) {
	v.addErrAt(err, -1, v.parser.pt.position)
}

// addErrAt adds the error at the specified position, for the instruction
// at instrIx.
func (v *ϡvm) addErrAt(err error, instrIx int, pos position) {
	var buf bytes.Buffer
	if v.filename != "" {
		buf.WriteString(v.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%s", pos))

	ruleNm := v.pg.ruleNameAt(instrIx)
	if ruleNm != "" {
		buf.WriteString(": ")
		buf.WriteString("rule " + ruleNm)
	}

	pe := &parserError{Inner: err, ϡprefix: buf.String()}
	v.errs.ϡadd(pe)
}

// dumpSnapshot writes a dump of the current VM state to w.
func (v *ϡvm) dumpSnapshot(w io.Writer) {
	var buf bytes.Buffer

	if v.filename != "" {
		buf.WriteString(v.filename + ":")
	}
	buf.WriteString(fmt.Sprintf("%s: %#U\n", v.parser.pt.position, v.parser.pt.rn))

	// write the next 5 instructions
	ix := v.pc - 1
	if ix > 0 {
		ix--
	}
	stdFmt := ". [%d]: %s"
	for i := 0; i < 5; i++ {
		stdFmt := stdFmt
		if ix == v.pc-1 {
			stdFmt = ">" + stdFmt[1:]
		}
		instr := v.pg.instrs[ix]
		op, n, _, _, _ := instr.decode()
		switch op {
		case ϡopCall:
			buf.WriteString(fmt.Sprintf(stdFmt+"\n", ix, v.pg.instrToString(instr, ix)))
			ix = v.i.pop() // continue with instructions at this index
			v.i.push(ix)
			continue
		default:
			buf.WriteString(fmt.Sprintf(stdFmt+"\n", ix, v.pg.instrToString(instr, ix)))
		}
		ix++
		n -= 3
		for n > 0 {
			ix++
			n -= 4
		}
		if ix >= len(v.pg.instrs) {
			break
		}
	}

	// print the stacks
	buf.WriteString("[ P: ")
	for i := 0; i < 3; i++ {
		if len(v.p) <= i {
			break
		}
		if i > 0 {
			buf.WriteString(", ")
		}
		val := v.p[len(v.p)-i-1]
		buf.WriteString(fmt.Sprintf("\"%v\"", val))
	}
	buf.WriteString(" ]\n[ V: ")
	for i := 0; i < 3; i++ {
		if len(v.v) <= i {
			break
		}
		if i > 0 {
			buf.WriteString(", ")
		}
		val := v.v[len(v.v)-i-1]
		buf.WriteString(fmt.Sprintf("%#v", val))
	}
	buf.WriteString(" ]\n[ I: ")
	for i := 0; i < 3; i++ {
		if len(v.i) <= i {
			break
		}
		if i > 0 {
			buf.WriteString(", ")
		}
		val := v.i[len(v.i)-i-1]
		buf.WriteString(fmt.Sprintf("%d", val))
	}
	buf.WriteString(" ]\n[ L: ")
	for i := 0; i < 3; i++ {
		if len(v.l) <= i {
			break
		}
		if i > 0 {
			buf.WriteString(", ")
		}
		val := v.l[len(v.l)-i-1]
		buf.WriteString(fmt.Sprintf("%v", val))
	}
	buf.WriteString(" ]\n")
	fmt.Fprintln(w, buf.String())
}

// run executes the provided program in this VM, and returns the result.
func (v *ϡvm) run(pg *ϡprogram) (interface{}, error) {
	v.pg = pg
	v.a = make(ϡastack, 0, 128)
	v.i = make(ϡistack, 0, 128)
	v.v = make(ϡvstack, 0, 128)
	v.l = make(ϡlstack, 0, 128)
	v.p = make(ϡpstack, 0, 128)
	ret := v.dispatch()

	// if the match failed, translate that to a nil result and make
	// sure it returns an error
	if ret == ϡmatchFailed {
		ret = nil
		if len(v.errs) == 0 {
			v.addErr(errNoMatch)
		}
	}

	return ret, v.errs.ϡerr()
}

// dispatch is the proper execution method of the VM, it loops over
// the instructions and executes each opcode.
func (v *ϡvm) dispatch() interface{} {
	var instrPath []int
	if v.debug {
		fmt.Fprintln(os.Stderr, v.pg)
		defer func() {
			var buf bytes.Buffer

			buf.WriteString("Execution path:\n")
			for _, ix := range instrPath {
				buf.WriteString(fmt.Sprintf("[%3d]: %s\n", ix, v.pg.instrToString(v.pg.instrs[ix], ix)))
			}
			fmt.Fprintln(os.Stderr, buf.String())
		}()
	}

	if v.recover {
		defer func() {
			if e := recover(); e != nil {
				switch e := e.(type) {
				case error:
					v.addErrAt(e, v.pc-1, v.parser.pt.position)
				default:
					v.addErrAt(fmt.Errorf("%v", e), v.pc-1, v.parser.pt.position)
				}
			}
		}()
	}

	// move to first rune before starting the loop
	v.parser.read()
	for {
		// fetch and decode the instruction
		instr := v.pg.instrs[v.pc]
		op, n, a0, a1, a2 := instr.decode()
		instrPath = append(instrPath, v.pc)

		// increment program counter
		v.pc++

		switch op {
		case ϡopCall:
			if v.debug {
				v.dumpSnapshot(os.Stderr)
			}
			ix := v.i.pop()
			v.i.push(v.pc)
			v.pc = ix

		case ϡopCallA:
			if v.debug {
				v.dumpSnapshot(os.Stderr)
			}
			v.v.pop()
			start := v.p.pop()
			v.cur.pos = start.position
			v.cur.text = v.parser.sliceFrom(start)
			if a0 >= len(v.pg.as) {
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
			fn := v.pg.as[a0]
			val, err := fn(v)
			if err != nil {
				v.addErrAt(err, v.pc-1, start.position)
			}
			v.v.push(val)

		case ϡopCallB:
			if v.debug {
				v.dumpSnapshot(os.Stderr)
			}
			v.cur.pos = v.parser.pt.position
			v.cur.text = nil
			if a0 >= len(v.pg.bs) {
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
			fn := v.pg.bs[a0]
			val, err := fn(v)
			if err != nil {
				v.addErrAt(err, v.pc-1, v.parser.pt.position)
			}
			if !val {
				v.v.push(ϡmatchFailed)
				break
			}
			v.v.push(nil)

		case ϡopCumulOrF:
			va, vb := v.v.pop(), v.v.pop()
			if va == ϡmatchFailed {
				v.v.push(ϡmatchFailed)
				break
			}
			switch vb := vb.(type) {
			case []interface{}:
				vb = append(vb, va)
				v.v.push(vb)
			case ϡsentinel:
				v.v.push([]interface{}{va})
			default:
				panic(fmt.Sprintf("invalid %s value type on the V stack: %T", op, vb))
			}

		case ϡopExit:
			return v.v.pop()

		case ϡopNilIfF:
			if top := v.v.pop(); top == ϡmatchFailed {
				v.v.push(nil)
				break
			}
			v.v.push(ϡmatchFailed)

		case ϡopNilIfT:
			if top := v.v.pop(); top != ϡmatchFailed {
				v.v.push(nil)
				break
			}
			v.v.push(ϡmatchFailed)

		case ϡopJump:
			v.pc = a0

		case ϡopJumpIfF:
			if top := v.v.peek(); top == ϡmatchFailed {
				v.pc = a0
			}

		case ϡopJumpIfT:
			if top := v.v.peek(); top != ϡmatchFailed {
				v.pc = a0
			}

		case ϡopMatch:
			start := v.parser.pt
			if a0 >= len(v.pg.ms) {
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
			m := v.pg.ms[a0]
			if ok := m.match(v.parser); ok {
				v.v.push(v.parser.sliceFrom(start))
				break
			}
			v.v.push(ϡmatchFailed)
			v.parser.pt = start

			if v.debug {
				v.dumpSnapshot(os.Stderr)
			}

		case ϡopPop:
			switch a0 {
			case ϡlstackID:
				v.l.pop()
			case ϡpstackID:
				v.p.pop()
			case ϡastackID:
				v.a.pop()
			case ϡvstackID:
				v.v.pop()
			default:
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}

		case ϡopPopVJumpIfF:
			if top := v.v.peek(); top == ϡmatchFailed {
				v.v.pop()
				v.pc = a0
			}

		case ϡopPush:
			switch a0 {
			case ϡpstackID:
				v.p.push(v.parser.pt)
			case ϡistackID:
				v.i.push(a1)
			case ϡvstackID:
				if a1 >= len(ϡvSpecialValues) {
					panic(fmt.Sprintf("invalid %s V stack argument: %d", op, a1))
				}
				v.v.push(ϡvSpecialValues[a1])
			case ϡastackID:
				v.a.push()
			case ϡlstackID:
				// n = L args to push + 1, for the lstackID
				n--
				ar := make([]int, n)
				src := []int{a1, a2}
				n -= 2
				for n > 0 {
					// need more
					instr := v.pg.instrs[v.pc]
					a0, a1, a2, a3 := instr.decodeLs()
					src = append(src, a0, a1, a2, a3)
					v.pc++
					n -= 4
				}
				copy(ar, src)
				v.l.push(ar)
			default:
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}

		case ϡopRestore:
			pt := v.p.pop()
			v.parser.pt = pt

		case ϡopRestoreIfF:
			pt := v.p.pop()
			if top := v.v.peek(); top == ϡmatchFailed {
				v.parser.pt = pt
			}

		case ϡopReturn:
			ix := v.i.pop()
			v.pc = ix

		case ϡopStoreIfT:
			if top := v.v.peek(); top != ϡmatchFailed {
				// get the label name
				if a0 >= len(v.pg.ss) {
					panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
				}
				lbl := v.pg.ss[a0]

				// store the value
				as := v.a.peek()
				as[lbl] = top
			}

		case ϡopTakeLOrJump:
			ix := v.l.take()
			if ix < 0 {
				v.pc = a0
				break
			}
			v.i.push(ix)

		default:
			panic(fmt.Sprintf("unknown opcode %s", op))
		}
	}
}
