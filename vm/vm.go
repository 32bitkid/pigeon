package vm

import (
	"bytes"
	"fmt"
)

// ϡsentinel is a type used to define sentinel values that shouldn't
// be equal to something else.
type ϡsentinel int

const (
	// ϡmatchFailed is a sentinel value used to indicate a match failure.
	ϡmatchFailed ϡsentinel = iota
)

const (
	// stack IDs, used in PUSH and POP's first argument
	ϡpstackID = iota + 1
	ϡlstackID
	ϡvstackID
	ϡistackID
)

// special values that may be pushed on the V stack.
var ϡvSpecialValues = []interface{}{
	nil,
	ϡmatchFailed,
	[]interface{}(nil),
}

type ϡmemoizedResult struct {
	v  interface{}
	pt ϡsvpt
}

// ϡtheProgram is the variable that holds the program generated by the
// builder for the input PEG.
var ϡtheProgram *ϡprogram

// ϡprogram is the data structure that is generated by the builder
// based on an input PEG. It contains the program information required
// to execute the grammar using the vm.
type ϡprogram struct {
	instrs []ϡinstr

	// lists
	ms []ϡmatcher
	as []func(*ϡvm) (interface{}, error)
	bs []func(*ϡvm) (bool, error)
	ss []string

	// instrToRule is the mapping of an instruction index to a rule
	// identifier (or display name) in the ss list:
	//
	// ss[instrToRule[instrIndex]] == name of the rule
	//
	// Since instructions are limited to 65535, the size of this slice
	// is bounded to a reasonable number.
	instrToRule []int
}

type ϡvm struct {
	// input
	filename string
	parser   *ϡparser

	// options
	debug   bool
	memoize bool
	recover bool
	// TODO : no bounds checking option (for stacks)? benchmark to see if it's worth it.

	// program data
	pc    int
	depth int
	pg    *ϡprogram

	// stacks
	p       ϡpstack
	l       ϡlstack
	v       ϡvstack
	i       ϡistack
	varSets []map[string]interface{}

	// TODO: memoization...

	// error list
	errs errList
}

// setOptions applies the options in sequence on the vm. It returns the
// vm to allow for chaining calls.
func (v *ϡvm) setOptions(opts []Option) *ϡvm {
	for _, opt := range opts {
		opt(v)
	}
	return v
}

func (v *ϡvm) addErr(err error) {
	v.addErrAt(err, v.parser.pt.position)
}

func (v *ϡvm) addErrAt(err error, pos position) {
	var buf bytes.Buffer
	if v.filename != "" {
		buf.WriteString(v.filename)
	}
	if buf.Len() > 0 {
		buf.WriteString(":")
	}
	buf.WriteString(fmt.Sprintf("%s", pos))
	// TODO : add rule ID or display name
	// if len(p.rstack) > 0 {
	// 	if buf.Len() > 0 {
	// 		buf.WriteString(": ")
	// 	}
	// 	rule := p.rstack[len(p.rstack)-1]
	// 	if rule.displayName != "" {
	// 		buf.WriteString("rule " + rule.displayName)
	// 	} else {
	// 		buf.WriteString("rule " + rule.name)
	// 	}
	// }
	pe := &parserError{Inner: err, ϡprefix: buf.String()}
	v.errs.ϡadd(pe)
}

// run executes the provided program in this VM, and returns the result.
func (v *ϡvm) run(pg *ϡprogram) (interface{}, error) {
	v.pg = pg
	// TODO : add a vm.init() or reset()?
	ret := v.dispatch()

	// if the match failed, translate that to a nil result and make
	// sure it returns an error
	if ret == ϡmatchFailed {
		ret = nil
		if len(v.errs) == 0 {
			v.addErr(errNoMatch)
		}
	}

	return ret, v.errs.ϡerr()
}

// dispatch is the proper execution method of the VM, it loops over
// the instructions and executes each opcode.
func (v *ϡvm) dispatch() interface{} {
	for {
		// fetch and decode the instruction
		instr := v.pg.instrs[v.pc]
		op, n, a0, a1, a2 := instr.decode()
		_, _, _, _ = n, a0, a1, a2

		// increment program counter
		v.pc++

		switch op {
		case ϡopCall:
		case ϡopCallA:
		case ϡopCallB:
		case ϡopCumulOrF:
		case ϡopDebug:
		case ϡopExit:
			return v.v.pop()
		case ϡopFalseIfF:
		case ϡopJump:
			v.pc = a0
		case ϡopJumpIfF:
		case ϡopJumpIfT:
		case ϡopMatch:
		case ϡopPop:
			switch a0 {
			case ϡlstackID:
				v.l.pop()
			case ϡpstackID:
				v.p.pop()
			default:
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
		case ϡopPopVJumpIfF:
		case ϡopPush:
			switch a0 {
			case ϡpstackID:
				v.p.push(v.parser.pt)
			case ϡistackID:
				v.i.push(a1)
			case ϡvstackID:
				if a1 >= len(ϡvSpecialValues) {
					panic(fmt.Sprintf("invalid %s V stack argument: %d", op, a1))
				}
				v.v.push(ϡvSpecialValues[a1])
			case ϡlstackID:
			default:
				panic(fmt.Sprintf("invalid %s argument: %d", op, a0))
			}
		case ϡopRestore:
			pt := v.p.pop()
			v.parser.pt = pt
		case ϡopRestoreIfF:
		case ϡopReturn:
		case ϡopStoreIfT:
		case ϡopTakeLOrJump:
		case ϡopTrueIfF:
		}
	}
}
