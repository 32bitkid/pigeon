package vm

// ϡsentinel is a type used to define sentinel values that shouldn't
// be equal to something else.
type ϡsentinel int

// ϡmatchFailed is a sentinel value used to indicate a match failure.
const ϡmatchFailed ϡsentinel = iota

type ϡmemoizedResult struct {
	v  interface{}
	pt ϡsvpt
}

// ϡtheProgram is the variable that holds the program generated by the
// builder for the input PEG.
var ϡtheProgram *ϡprogram

// ϡprogram is the data structure that is generated by the builder
// based on an input PEG. It contains the program information required
// to execute the grammar using the vm.
type ϡprogram struct {
	instrs []ϡinstr

	// lists
	ms []ϡmatcher
	as []func(*ϡvm) (interface{}, error)
	bs []func(*ϡvm) (bool, error)
	ss []string
}

type ϡvm struct {
	// input
	filename string
	parser   *ϡparser

	// options
	debug   bool
	memoize bool
	recover bool

	// runtime state
	pc int
	pg *ϡprogram

	// stacks
	p ϡpstack
	l ϡlstack
	v ϡvstack
	i ϡistack

	// error list
	errs *errList
}

// setOptions applies the options in sequence on the vm. It returns the
// vm to allow for chaining calls.
func (v *ϡvm) setOptions(opts []Option) *ϡvm {
	for _, opt := range opts {
		opt(v)
	}
	return v
}

// run executes the provided program in this VM, and returns the result.
func (v *ϡvm) run(pg *ϡprogram) (interface{}, error) {
	v.pg = pg
	// TODO : add a vm.init() or reset()?
	ret := v.dispatch()

	// if the match failed, translate that to a nil result and make
	// sure it returns an error
	if ret == ϡmatchFailed {
		ret = nil
		if len(*v.errs) == 0 {
			//TODO : v.addErr(errNoMatch)
		}
	}

	return ret, v.errs.ϡerr()
}

// dispatch is the proper execution method of the VM, it loops over
// the instructions and executes each opcode.
func (v *ϡvm) dispatch() interface{} {
	for {
		// fetch and decode the instruction
		instr := v.pg.instrs[v.pc]
		op, n, a0, a1, a2 := instr.decode()
		_, _, _, _ = n, a0, a1, a2

		// increment program counter
		v.pc++

		switch op {
		case ϡopCall:
		case ϡopCallA:
		case ϡopCallB:
		case ϡopCumulOrF:
		case ϡopDebug:
		case ϡopExit:
		case ϡopFalseIfF:
		case ϡopJump:
		case ϡopJumpIfF:
		case ϡopJumpIfT:
		case ϡopMatch:
		case ϡopPop:
		case ϡopPopVJumpIfF:
		case ϡopPush:
		case ϡopPushL:
		case ϡopRestore:
		case ϡopRestoreIfF:
		case ϡopReturn:
		case ϡopStoreIfT:
		case ϡopTakeLOrJump:
		case ϡopTrueIfF:
		}
	}
}
