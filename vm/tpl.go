package vm

import "text/template"

var tpl = template.New("gen")

// type thunkInfo struct {
// 	Parms  []string
// 	RuleNm string
// 	ExprIx int
// 	Code   string
// }
//
// type program struct {
//  RecvrNm string
// 	Init    string
// 	Instrs  []ϡinstr
//
// 	Ms []ast.Expression
// 	As []*thunkInfo
// 	Bs []*thunkInfo
// 	Ss []string
//
// 	InstrToRule []int
//
// 	mss map[string]int // reverse map of string to index in Ss
// 	mms map[string]int // reverse map of matcher's raw value to index in Ms
//
// 	ruleNmIx      int
// 	exprIx        int
// 	parmsSet      [][]string  // stack of parms set for code blocks
// 	ruleNmStartIx map[int]int // rule name ix to first rule instr ix
// 	ruleNmEntryIx map[int]int // rule name ix to entry point instr ix
// 	ruleNmToDisNm map[int]int // rule name ix to rule display name ix
// }

const codeTpl = `// Code generated by pigeon (https://github.com/PuerkitoBio/pigeon)
// on {{.Now}}
{{if .Init}}
{{.Init}}
{{end}}{{range .As}}
func ({{$.RecvrNm}} *current) on{{.RuleNm}}{{.ExprIx}}({{range $index, $elem := .Parms}}{{if (gt $index 0)}}, {{end}}{{$elem}}{{end}}{{if .Parms}} interface{}{{end}}) (interface{}, error) {
{{ .Code }}
}

func (v *ϡvm) callOn{{.RuleNm}}{{.ExprIx}}() (interface{}, error) {
{{if .Parms}}stack := v.a.peek()
{{end}}return v.cur.on{{.RuleNm}}{{.ExprIx}}({{range $index, $elem := .Parms}}{{if (gt $index 0)}}, {{end}}stack[{{printf "%q" $elem}}]{{end}})
}
{{end}}{{range .Bs}}
func ({{$.RecvrNm}} *current) on{{.RuleNm}}{{.ExprIx}}({{range $index, $elem := .Parms}}{{if (gt $index 0)}}, {{end}}{{$elem}}{{end}}{{if .Parms}} interface{}{{end}}) (bool, error) {
{{ .Code }}
}

func (v *ϡvm) callOn{{.RuleNm}}{{.ExprIx}}() (bool, error) {
{{if .Parms}}stack := v.a.peek()
{{end}}return v.cur.on{{.RuleNm}}{{.ExprIx}}({{range $index, $elem := .Parms}}{{if (gt $index 0)}}, {{end}}stack[{{printf "%q" $elem}}]{{end}})
}
{{end}}
var ϡtheProgram = &ϡprogram{
instrs: []ϡinstr{
{{range $index, $elem := .Instrs}}{{if (not (mod $index 3))}}{{printf "\n"}}{{end}}{{$elem}}, {{end}}
},
}
`

var funcMap = template.FuncMap{
	"mod": func(ix, div int) int {
		if ix == 0 {
			return 1
		}
		return ix % div
	},
}

func init() {
	template.Must(tpl.Funcs(funcMap).Parse(codeTpl))
}
